unit controladores;

interface

uses modelos, Generics.collections, SysUtils, Classes;

type
  TManipuladorArquivo = class
    /// variavel para refenciar arquivo;
    ///
  private
    linhaEntrada: string;
    linhaSaida: string;
    arquivo: TextFile;
  protected

  public

    function proximo: string;
    function header: string;
    function salvar: boolean;
    constructor create; overload;
    constructor create(arquivoEntrada: string); overload;
    procedure fecharArquivo;

  end;

type
  TControlador = class
  const

    insertSQL: string = ' insert into '; // insert
    valuesSQL: string = ' values '; // valores

  private
    separador: string ;
    header: array of string;
    arquivoEntrada: TManipuladorArquivo;
    arquivoSaida: TManipuladorArquivo;

    campos: array of string;
    function setCamposInsert(valores: array of string): boolean;
    // configura os headers
    function camposValues(valores: array of string): string;
    // formata os campos a sere inserido
  protected

  public
    function getCampos: string;
    function getDados: string;
    function processar: string;
    constructor create; overload;
    constructor create(arquivoEntrada, arquivoSaida,
      separador: string); overload;

  end;

implementation

{ Controller }

constructor TControlador.create;
begin

end;

function TControlador.processar: string;

var
  modelo: Metadado;
  Campo: array of string;
  Valor: array of string;
  resultado: String;
  dados: TDictionary<string, string>;
  retorno: string;
  i: integer;
  Key: string;
  tmpString: string;
  var list : TstringList;
begin
  tmpString := arquivoEntrada.proximo;
  if tmpString <> '' then

  begin
  try
  //configura para realizar o recorte
  list := TstringList.Create;
  list.QuoteChar:= chr(9);
  list.StrictDelimiter:= false;
  list.DelimitedText := tmpString;

  SetLength( valor, list.Count);
  //configura a array para o tamanho da ista
  for I := 0 to list.Count do begin
     valor[i] :=  list[i];
  end;

    //    ExtractStrings ([chr(9)], tmpString,  Valor);
    //Split(chr(9), tmpString, outputlist);
    //Split(chr(9), tmpString, valor);
  finally

  end;
  end;

  modelo.create(Campos, Valor);

  dados := modelo.getDados;
  i := 0;

  for Key in dados.Keys do
  begin
    // for I := 0 to High(dados.Count) do begin
    if (dados.TryGetValue(Campo[i], resultado)) then
    begin

      retorno := Key + ' | ' + resultado +

        AnsiString(#13#10);
    end;
    i := i + 1;
  end;
  result := retorno;
end;

function TControlador.camposValues(valores: array of string): string;
begin

end;

function TControlador.setCamposInsert(valores: array of string): boolean;
begin

end;

constructor TControlador.create(arquivoEntrada, arquivoSaida, separador: string);
var
i: integer;
  Key: string;
  tmpString: string;
  var list : TstringList;
begin
  try
    Self.arquivoEntrada := TManipuladorArquivo.create(arquivoEntrada);
    Self.arquivoSaida := TManipuladorArquivo.create(arquivoSaida);
    Self.separador := separador;
    //Self.campos := Self.arquivoEntrada.header;

    tmpString:= Self.arquivoEntrada.header;
    list := TstringList.Create;
    list.QuoteChar:= chr(9);
    list.StrictDelimiter:= false;
    list.DelimitedText := tmpString;

    SetLength( Self.campos, list.Count);
    //configura a array para o tamanho da ista
    for I := 0 to list.Count do begin
       Self.campos[i] :=  list[i];
    end;


//    Self.insertSQL := ' insert into '; // insert
  //  Self.valuesSQL := ' values ';
  finally

  end;
end;

function TControlador.getCampos: string;
begin
   ///return ( campo1, campo2, campo3 )
end;

function TControlador.getDados: string;
begin
   ///return (variavel1, variavel2, variavel3)
end;

{ TManipuladorArquivo }

constructor TManipuladorArquivo.create;
begin

end;

procedure TManipuladorArquivo.fecharArquivo;
begin
  CloseFile(Self.arquivo);
end;

constructor TManipuladorArquivo.create(arquivoEntrada: string);
begin
  try
    AssignFile(Self.arquivo, linhaEntrada);
{$I-}
    reset(Self.arquivo);
{$I+}
  finally

  end;
end;

function TManipuladorArquivo.header: string; // deve ser utilizado primeiro

begin
  result := proximo();
end;

function TManipuladorArquivo.proximo: string;
var
  linha: string;
begin
  try
    result := '';
    if (not eof(Self.arquivo)) then
    begin
      readln(Self.arquivo, linha);
      result := linha;
    end;
  finally

  end;
end;

function TManipuladorArquivo.salvar: boolean;
begin

end;

end.
